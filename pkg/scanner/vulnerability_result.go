package scanner

import (
	"log"
	"strconv"

	"github.com/DataDog/datadog-sbom-generator/pkg/lockfile"

	"github.com/DataDog/datadog-sbom-generator/internal/utility/fileposition"
	"github.com/DataDog/datadog-sbom-generator/internal/utility/location"
	"github.com/DataDog/datadog-sbom-generator/pkg/models"
	"github.com/DataDog/datadog-sbom-generator/pkg/reporter"
)

func exportMetadata(rawPkg lockfile.PackageDetails, reachabilityAnalysisResults *models.ReachabilityAnalysisResults) map[models.PackageMetadataType]string {
	metadata := make(map[models.PackageMetadataType]string)

	if len(rawPkg.PackageManager) > 0 && rawPkg.PackageManager != models.Unknown {
		metadata[models.PackageManagerMetadata] = string(rawPkg.PackageManager)
	}
	if rawPkg.IsDirect {
		metadata[models.IsDirectDependencyMetadata] = strconv.FormatBool(rawPkg.IsDirect)
	}
	if rawPkg.Ecosystem.IsDevGroup(rawPkg.DepGroups) {
		metadata[models.IsDevDependencyMetadata] = strconv.FormatBool(true)
	}
	if reachabilityAnalysisResults != nil {
		if !rawPkg.IsDirect && len(reachabilityAnalysisResults.ReachableVulnerabilities) > 0 {
			log.Printf("transitive package (%s) with reachable symbols was dropped\n", rawPkg.PURL)
		} else {
			for _, vuln := range reachabilityAnalysisResults.ReachableVulnerabilities {
				key := models.ReachableSymbolLocationMetadata.WithValue(vuln.AdvisoryID)
				val, err := vuln.ReachableSymbolLocations.MarshalToJSONString()
				if err != nil {
					log.Printf("failed to marshal reachable symbol locations into a JSON string: %s\n", err)
					continue
				}
				metadata[key] = val
			}
		}
	}

	return metadata
}

// grouped by source location.
func groupBySource(r reporter.Reporter, packages []lockfile.PackageDetails, artifacts []models.ScannedArtifact, reachabilityAnalysis models.ReachabilityAnalysis) models.VulnerabilityResults {
	output := models.VulnerabilityResults{
		Results:   []models.PackageSource{},
		Artifacts: artifacts,
	}
	groupedBySource := map[models.SourceInfo][]models.PackageVulns{}

	for _, p := range packages {
		var pkg models.PackageVulns
		switch {
		case p.Ecosystem != "" && p.Name != "":
			pkg = models.PackageVulns{
				Package: models.PackageInfo{
					Name:      p.Name,
					Version:   p.Version,
					Ecosystem: string(p.Ecosystem),
					Purl:      p.PURL,
				},
				Metadata: exportMetadata(p, reachabilityAnalysis.PurlToReachabilityAnalysisResults[p.PURL]),
			}
		case p.Commit != "":
			pkg.Package.Version = p.Commit
			pkg.Package.Ecosystem = "GIT"
		default:
			r.Warnf("package %v does not have a commit, PURL or ecosystem/name/version identifier\n", p)
			continue
		}

		pkg.Vulnerabilities = nil
		if fileposition.IsFilePositionExtractedSuccessfully(p.BlockLocation) {
			pkg.Locations = make([]models.PackageLocations, 1)
			pkg.Locations[0] = location.NewPackageLocations(p.BlockLocation, p.NameLocation, p.VersionLocation)
		} else {
			pkg.Locations = make([]models.PackageLocations, 0)
		}
		if _, ok := reachabilityAnalysis.PurlToReachabilityAnalysisResults[p.PURL]; ok {
			pkg.AdvisoriesForReachability = reachabilityAnalysis.PurlToReachabilityAnalysisResults[p.PURL].AdvisoryIdsChecked
		}

		groupedBySource[p.Source] = append(groupedBySource[p.Source], pkg)
	}

	for source, packages := range groupedBySource {
		output.Results = append(output.Results, models.PackageSource{
			Source:   source,
			Packages: packages,
		})
	}

	return output
}
